
package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
//import java.util.Optional;
//import java.util.stream.Collectors;
import java.util.stream.Collectors;

import com.example.demo.dto.AnswerSubmissionDTO;
import com.example.demo.dto.ExamSubmissionDTO;
import com.example.demo.dto.QuestionDTO;

import com.example.demo.dto.ResponseSummaryDTO;

import com.example.demo.dto.UserResponseDTO;
import com.example.demo.model.Exam;
import com.example.demo.model.Question;
import com.example.demo.model.Response;
import com.example.demo.service.ExamService;
import com.example.demo.service.QuestionService;
import com.example.demo.service.ResponseService;

@RestController
@RequestMapping("/api/exams")
public class ExamController {
	
	@Autowired
	private ExamService examService;
	
	@Autowired
	private QuestionService questionService;
	
	@Autowired
	private ResponseService responseService;
	
	@PostMapping
	public Exam createExam(@RequestBody Exam exam) {
		return examService.createExam(exam);
	}
	
	@GetMapping
	public List<Exam> getAllExams(){
		return examService.getAllExams();	
	}
	
	@PostMapping("/{examId}/questions")
	public Question addQuestion(@PathVariable Long examId, @RequestBody Question question) {
		Exam exam = examService.getExamById(examId);
		question.setExam(exam);
		return questionService.addQuestion(question);
	}
	@PostMapping("/{examId}/mulquestions")
	public List<Question> addMultipleQuestions(@PathVariable Long examId, @RequestBody List<Question> question) {
		Exam exam = examService.getExamById(examId);
		for(Question q:question) {
		q.setExam(exam);
		}
		return questionService.addMultipleQuestions(question);
		
	}
	
	/*@GetMapping("/{examId}/questions")
	public ResponseEntity<List<QuestionDTO>> getQuestionsByExam(@PathVariable Long examId) {
	   List<Question> questions = questionService.getQuestionsByExam(examId);
	   List<QuestionDTO> dtoList = questions.stream().map(q -> convertToDTO(q))
	    .collect(Collectors.toList());
	   return ResponseEntity.ok(dtoList);
	}
	*/
	
	@GetMapping("/{examId}/questions")
	public ResponseEntity<List<QuestionDTO>> getQuestionsByExam(@PathVariable Long examId) {
	    List<Question> questions = questionService.getQuestionsByExam(examId);
	    List<QuestionDTO> dtoList = new ArrayList<>();

	    // Iterate over each question and convert it into a QuestionDTO
	    for (Question question : questions) {
	        QuestionDTO dto = new QuestionDTO();
	        dto.setQuestionId(question.getQuestionId());
	        dto.setQuestionText(question.getQuestionText());
	        dto.setCategory(question.getCategory());
	        dto.setDifficulty(question.getDifficulty());
	        dto.setOption1(question.getOption1());
	        dto.setOption2(question.getOption2());
	        // Map additional fields as required. For example:
	         dto.setMaxMarks(question.getMaxMarks());
	        // dto.setCorrectAnswer(question.getCorrectAnswer());
	        
	        dtoList.add(dto);
	    }
	    return ResponseEntity.ok(dtoList);
	}
	
	
	/*@PostMapping("/{examId}/submit")
	public ResponseEntity<?> submitExam(@PathVariable Long examId, @RequestBody ExamSubmissionDTO submissionDTO) {
		List<Response> savedResponses=new ArrayList<>();
		Exam exam = examService.getExamById(examId);
		for(AnswerSubmissionDTO ans : submissionDTO.getAnswers()) {
			Question question = questionService.getQuestionById(ans.getQuestionId());
			
			Response response = new Response();
			response.setUserId(submissionDTO.getUserId());
			response.setExam(exam);
			response.setQuestion(question);
			response.setSubmittedAnswer(ans.getSubmittedAnswer());
			
			int marks=question.getCorrectAnswer().equals(ans.getSubmittedAnswer())?question.getMaxMarks():0;
			response.setMarksObtained(marks);
			savedResponses.add(responseService.submitResponse(response));
		}
		return ResponseEntity.ok(savedResponses);
	}*/
	@PostMapping("/{examId}/submit")
	public ResponseEntity<?> submitExam(@PathVariable Long examId, @RequestBody ExamSubmissionDTO submissionDTO) {
	    List<ResponseSummaryDTO> responseSummaries = new ArrayList<>();
	    Exam exam = examService.getExamById(examId);

	    for (AnswerSubmissionDTO ans : submissionDTO.getAnswers()) {
	        Question question = questionService.getQuestionById(ans.getQuestionId());

	        Response response = new Response();
	        response.setUserId(submissionDTO.getUserId());
	        response.setExam(exam);
	        response.setQuestion(question);
	        response.setSubmittedAnswer(ans.getSubmittedAnswer());

	        int marks = question.getCorrectAnswer().equals(ans.getSubmittedAnswer()) ? question.getMaxMarks() : 0;
	        response.setMarksObtained(marks);

	        Response savedResponse = responseService.submitResponse(response);

	        ResponseSummaryDTO summary = new ResponseSummaryDTO(
	            savedResponse.getResponseId(),
	            question.getQuestionId(),
	            ans.getSubmittedAnswer(),
	            marks
	        );
	        responseSummaries.add(summary);
	    }

	    return ResponseEntity.ok(responseSummaries);
	}
	
	@GetMapping("/responses/{userId}")
	public ResponseEntity<Map<Long, Map<Long, List<UserResponseDTO>>>> getUserResponse(@PathVariable Long userId) {
	    List<Response> responses = responseService.getResponsesByUser(userId);

	    List<UserResponseDTO> Responses = responses.stream()
	        .map(r -> new UserResponseDTO(
	        		 r.getUserId(),
	        		 r.getQuestion().getQuestionId(),
	        		 r.getSubmittedAnswer(),
	        		 r.getMarksObtained(),
	        		 r.getExam().getExamId(),
	            r.getResponseId()            
	                    
	        ))
	        .collect(Collectors.toList());

	    // Group by userId -> examId
	    Map<Long, Map<Long, List<UserResponseDTO>>> grouped = Responses.stream()
	        .collect(Collectors.groupingBy(
	            UserResponseDTO::getUserId,
	            Collectors.groupingBy(UserResponseDTO::getExamId)
	        ));

	    return ResponseEntity.ok(grouped);
	}

	
	//examiner AND ADMIN
	/*@GetMapping("/responses/{userId}")
	public List<Response> getUserResponse(@PathVariable Long userId){
		return responseService.getResponsesByUser(userId);
	}*/
	
	/*@GetMapping("/responses/{userId}")
	public ResponseEntity<List<UserResponseDTO>> getUserResponse(@PathVariable Long userId) {
	    List<Response> responses = responseService.getResponsesByUser(userId);
	    List<UserResponseDTO> responseDTOs = responses.stream()
	        .map(response -> new UserResponseDTO(
	            response.getUserId(),
	            response.getQuestion().getQuestionId(),
	            response.getSubmittedAnswer(),
	            response.getMarksObtained(),
	            response.getExam().getExamId(),
	            response.getResponseId()
	        ))
	        .collect(Collectors.toList());

	    return ResponseEntity.ok(responseDTOs);
	}*/

	/*@GetMapping("/responses/{userId}")
	public ResponseEntity<Optional<Response>> getUserResponses(@PathVariable Long userId) {
	    Optional<Response> responses = responseService.getResponsesByUser(userId);
	    return ResponseEntity.ok(responses);
	}*/
	
	


	
	@DeleteMapping("/{examId}")
	public String deleteExam(@PathVariable Long examId) {
		examService.deleteExam(examId);
		return "Exam deleted successfully.";
	}
	
	@DeleteMapping("{examid}/questions/{questionId}")
	public String deleteQuestion(@PathVariable Long questionId) {
		questionService.deleteQuestion(questionId);
		return "Question deleted successfully.";
	}
		
	
}


package com.example.demo.model;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import lombok.Data;

@Data
@Entity
public class Exam {

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private long examId;
	
	private String title;
	private String description;
	private int duration;
	private int totalMarks;
	
	@OneToMany(mappedBy="exam",cascade = CascadeType.ALL)
	@JsonManagedReference
	private List<Question> questions;
}

package com.example.demo.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
//import com.fasterxml.jackson.annotation.JsonIgnore;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
public class Question {

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Long questionId;
	
	@ManyToOne
	@JsonBackReference
	@JoinColumn(name="exam_id")
	private Exam exam;
	
	private String questionText;
	
	private String option1;
	private String option2;
	
	//@JsonIgnore
	private String correctAnswer;
	
	private String category;
	private String difficulty;
	
	private int maxMarks;
	
	//private String correctAnswer;
}


package com.example.demo.model;

import com.fasterxml.jackson.annotation.JsonIgnore;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
public class Response {

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Long responseId;
	//private Long questionId;
	private Long userId;
	
	@ManyToOne
	@JoinColumn(name="exam_id")
	private Exam exam;
	
	@JsonIgnore
	@ManyToOne
	@JoinColumn(name="question_id")
	private Question question;
	
	private String submittedAnswer;
	private Integer marksObtained;
}

package com.example.demo.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.demo.model.Exam;
import com.example.demo.repository.ExamRepository;

@Service
public class ExamService {

	@Autowired
	private ExamRepository examRepository;
	
	public Exam createExam(Exam exam) {
		return examRepository.save(exam);
	}
	
	public List<Exam> getAllExams(){
		return examRepository.findAll();
	}
	
	public Exam getExamById(Long id) {
		return examRepository.findById(id).orElse(null);
	}
	
	public void deleteExam(Long examId) {
		 examRepository.deleteById(examId);
	}
	
}

package com.example.demo.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.demo.dto.QuestionDTO;
import com.example.demo.model.Question;
import com.example.demo.repository.QuestionRepository;

@Service
public class QuestionService {
	
	@Autowired
	private QuestionRepository questionRepository;
	
	public Question addQuestion(Question question) {
		return questionRepository.save(question);
	}
	
	public List<Question> addMultipleQuestions(List<Question> q)
	{
		return questionRepository.saveAll(q);
	}
	
	public List<Question> getQuestionsByExam(Long examId){
		return questionRepository.findByExamExamId(examId);
	}
	
	public Question getQuestionById(Long id) {
		return questionRepository.findById(id).orElse(null);
	}
	
	public void deleteQuestion(Long questionId) {
		questionRepository.deleteById(questionId);
	}
	public QuestionDTO convertToDTO(Question question) {
		   return new QuestionDTO(
		       question.getQuestionId(),
		       question.getQuestionText(),
		       question.getOption1(),
		       question.getOption2(),
		       question.getCategory(),
		       question.getDifficulty(),
		       question.getMaxMarks()
		   );
		}
}	


package com.example.demo.service;

import java.util.List;
//import java.util.List;
//import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

//import com.example.demo.model.Question;
import com.example.demo.model.Response;
//import com.example.demo.repository.QuestionRepository;
import com.example.demo.repository.ResponseRepository;

@Service
public class ResponseService {
	
	@Autowired
	private ResponseRepository responseRepository;
	
	//@Autowired
	//private QuestionRepository questionRepository;
	
	
	public Response submitResponse(Response response) {
		/*Question question=questionRepository.findById(response.getQuestionId())
				.orElseThrow(() -> new RuntimeException("Question not Found"));
		
		if(question.getCorrectAnswer().equals(response.getSubmittedAnswer())) {
			response.setMarksObtained(question.getMaxMarks());		
		}
		else {
			response.setMarksObtained(0);
		}*/
		return responseRepository.save(response);
	}
	
	/*public Optional<Response> getResponsesByUser(Long userId){
		return responseRepository.findById(userId);
	}*/
	
	public List<Response> getResponsesByUser(Long userId){
		return responseRepository.findByUserId(userId);
	}
	

}

package com.example.demo.dto;

import lombok.Data;

@Data
public class AnswerSubmissionDTO {
	private long questionId;
	private String submittedAnswer;

}

package com.example.demo.dto;

import java.util.List;

import lombok.Data;

@Data
public class ExamSubmissionDTO {
	private Long userId;
	//private Long examId;
	private List<AnswerSubmissionDTO> answers;
}

package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class QuestionDTO {

	private Long questionId;
	private String questionText;
	
	private String option1;
	private String option2;
	private String category;
	private String difficulty;
	
	private Integer maxMarks;
}

package com.example.demo.dto;

import lombok.Data;

@Data
public class ResponseSummaryDTO {
    private Long responseId;
    private Long questionId;
    private String submittedAnswer;
    private int marksObtained;

    // Constructors
    public ResponseSummaryDTO(Long responseId, Long questionId, String submittedAnswer, int marksObtained) {
        this.responseId = responseId;
        this.questionId = questionId;
        this.submittedAnswer = submittedAnswer;
        this.marksObtained = marksObtained;
    }

    // Getters and Setters
    // (or use Lombok @Data for brevity)
}

package com.example.demo.dto;

//import lombok.AllArgsConstructor;
import lombok.Data;
//import lombok.NoArgsConstructor;

@Data
//@NoArgsConstructor
//@AllArgsConstructor
public class UserResponseDTO {
    private Long responseId;
    private Long questionId;
    private String submittedAnswer;
    private int marksObtained;
    private Long examId;
    private Long userId;

    public UserResponseDTO(Long userId, Long questionId, String submittedAnswer, int marksObtained, Long examId,Long responseId) {
        this.responseId = responseId;
        this.questionId = questionId;
        this.submittedAnswer = submittedAnswer;
        this.marksObtained = marksObtained;
        this.examId = examId;
        this.userId=userId;
        }
   /* public UserResponseDTO( Long questionId, String submittedAnswer, int marksObtained) {
       // this.responseId = responseId;
        this.questionId = questionId;
        this.submittedAnswer = submittedAnswer;
        this.marksObtained = marksObtained;
       // this.examId = examId;
       // this.userId=userId;
        }*/

    // Getters and Setters
}

















